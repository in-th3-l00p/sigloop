# x402

[<< Policy](policy.md) | [README](README.md) | [Next: Chain >>](chain.md)

---

## Package

```go
import "github.com/sigloop/sdk-go/x402"
```

The `x402` package implements the x402 payment protocol for HTTP-based micropayments. When an HTTP server responds with `402 Payment Required`, the transport layer automatically signs an EIP-3009 `TransferWithAuthorization` for USDC and retries the request with an `X-PAYMENT` header. The package includes budget tracking, payment policy enforcement, and a convenience client constructor.

---

## X402Transport

`X402Transport` implements `http.RoundTripper`. It intercepts 402 responses, signs payment authorizations, and retries transparently.

### Constructor

#### `NewX402Transport`

```go
func NewX402Transport(
    base http.RoundTripper,
    privateKey *ecdsa.PrivateKey,
    chainID *big.Int,
    budget *BudgetTracker,
    policy *X402Policy,
    config X402Config,
) *X402Transport
```

Creates a new `X402Transport`.

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `base` | `http.RoundTripper` | The underlying transport (nil defaults to `http.DefaultTransport`) |
| `privateKey` | `*ecdsa.PrivateKey` | Private key used to sign payment authorizations |
| `chainID` | `*big.Int` | Chain ID for EIP-712 domain separator |
| `budget` | `*BudgetTracker` | Budget tracker for spend tracking (may be nil) |
| `policy` | `*X402Policy` | Payment policy for allowlist enforcement (may be nil) |
| `config` | `X402Config` | Transport configuration |

**Returns:** `*X402Transport`

**Example:**

```go
privateKey, _ := crypto.GenerateKey()

transport := x402.NewX402Transport(
    nil, // use http.DefaultTransport
    privateKey,
    big.NewInt(8453),
    budgetTracker,
    &x402.X402Policy{
        MaxPerRequest: big.NewInt(1_000_000),
    },
    x402.X402Config{
        AutoPay:        true,
        AllowedSchemes: []string{"exact"},
    },
)
```

---

### Methods

#### `RoundTrip`

```go
func (t *X402Transport) RoundTrip(req *http.Request) (*http.Response, error)
```

Executes an HTTP request. If the response is `402 Payment Required` and `AutoPay` is enabled, the transport will:

1. Parse payment requirements from the response body.
2. Select a matching payment requirement (by scheme).
3. Check the amount against the policy (`MaxPerRequest`, `AllowedPayees`, `AllowedDomains`).
4. Check the budget tracker for remaining funds.
5. Build and sign an EIP-3009 payment header.
6. Retry the request with the `X-PAYMENT` header.
7. On success (2xx), record the payment in the budget tracker.

If any check fails or `AutoPay` is false, the original 402 response is returned unchanged.

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `req` | `*http.Request` | The outgoing HTTP request |

**Returns:**

| Type | Description |
|------|-------------|
| `*http.Response` | The HTTP response (either original or post-payment retry) |
| `error` | Non-nil only if the underlying transport fails |

**Example:**

```go
client := &http.Client{Transport: transport}
resp, err := client.Get("https://api.example.com/paid-endpoint")
if err != nil {
    log.Fatal(err)
}
defer resp.Body.Close()
// If the server returned 402 and policy allowed, payment was made automatically
```

---

## BudgetTracker

`BudgetTracker` tracks spending across a rolling time period. It is safe for concurrent use.

### Constructor

#### `NewBudgetTracker`

```go
func NewBudgetTracker(policy X402Policy, periodDuration uint64) *BudgetTracker
```

Creates a new `BudgetTracker`.

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `policy` | `X402Policy` | Payment policy with per-request and per-period limits |
| `periodDuration` | `uint64` | Budget period duration in seconds (e.g., 86400 for 24 hours) |

**Returns:** `*BudgetTracker` -- initialized with zero spending and a period starting at the current time.

**Example:**

```go
bt := x402.NewBudgetTracker(x402.X402Policy{
    MaxPerRequest: big.NewInt(1_000_000),
    MaxPerPeriod:  big.NewInt(50_000_000),
    AllowedPayees: map[common.Address]bool{
        common.HexToAddress("0xPayee"): true,
    },
}, 86400) // 24 hours
```

---

### Methods

#### `Track`

```go
func (bt *BudgetTracker) Track(record PaymentRecord) error
```

Records a payment and updates the budget state. Validates the payment against the policy before recording.

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `record` | `PaymentRecord` | The payment to record |

**Returns:** `error` -- non-nil if:
- Payee is not in the allowlist (when allowlist is set)
- Amount exceeds the per-request limit
- Amount would exceed the per-period budget

**Behavior:**
- Automatically resets the period if the current period has elapsed.
- Updates both `TotalSpent` and `PeriodSpent`.
- Appends the record to the records history.

**Example:**

```go
err := bt.Track(x402.PaymentRecord{
    Resource:  "https://api.example.com/data",
    Amount:    big.NewInt(500_000),
    PayTo:     common.HexToAddress("0xPayee"),
    Timestamp: uint64(time.Now().Unix()),
    Network:   "base",
})
if err != nil {
    log.Fatal(err)
}
```

---

#### `Check`

```go
func (bt *BudgetTracker) Check(amount *big.Int, payTo common.Address) error
```

Checks whether a proposed payment would be allowed without recording it. Uses the same validation logic as `Track`.

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `amount` | `*big.Int` | The proposed payment amount |
| `payTo` | `common.Address` | The proposed payee address |

**Returns:** `error` -- non-nil if the payment would violate policy.

**Example:**

```go
err := bt.Check(big.NewInt(2_000_000), common.HexToAddress("0xPayee"))
if err != nil {
    fmt.Printf("Payment would be rejected: %s\n", err)
}
```

---

#### `Remaining`

```go
func (bt *BudgetTracker) Remaining() *big.Int
```

Returns the remaining budget for the current period.

**Parameters:** None

**Returns:** `*big.Int` -- the remaining amount. Returns `-1` if no period limit is configured. Returns `0` if the budget is exhausted.

**Example:**

```go
remaining := bt.Remaining()
fmt.Printf("Remaining budget: %s\n", remaining.String())
```

---

#### `IsExhausted`

```go
func (bt *BudgetTracker) IsExhausted() bool
```

Returns whether the current period's budget has been fully spent.

**Parameters:** None

**Returns:** `bool` -- `true` if `PeriodSpent >= MaxPerPeriod`, `false` otherwise. Returns `false` if no period limit is configured.

**Example:**

```go
if bt.IsExhausted() {
    fmt.Println("Budget exhausted, waiting for period reset")
}
```

---

## Payment Signing Functions

### `SignEIP3009Authorization`

```go
func SignEIP3009Authorization(
    privateKey *ecdsa.PrivateKey,
    tokenAddress common.Address,
    from common.Address,
    to common.Address,
    value *big.Int,
    validAfter *big.Int,
    validBefore *big.Int,
    nonce [32]byte,
    chainID *big.Int,
) ([]byte, error)
```

Signs an EIP-3009 `TransferWithAuthorization` message. This produces an EIP-712 typed data signature over the USDC transfer parameters.

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `privateKey` | `*ecdsa.PrivateKey` | Signer's private key |
| `tokenAddress` | `common.Address` | The USDC token contract address |
| `from` | `common.Address` | Sender address |
| `to` | `common.Address` | Recipient address |
| `value` | `*big.Int` | Transfer amount |
| `validAfter` | `*big.Int` | Unix timestamp after which the authorization is valid |
| `validBefore` | `*big.Int` | Unix timestamp before which the authorization must be used |
| `nonce` | `[32]byte` | Unique nonce for the authorization |
| `chainID` | `*big.Int` | Chain ID for the EIP-712 domain |

**Returns:**

| Type | Description |
|------|-------------|
| `[]byte` | The 65-byte signature with recovery ID adjusted to >= 27 |
| `error` | Non-nil if signing fails |

**Example:**

```go
var nonce [32]byte
copy(nonce[:], crypto.Keccak256([]byte("unique-nonce")))

sig, err := x402.SignEIP3009Authorization(
    privateKey,
    common.HexToAddress("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"), // USDC on Base
    fromAddr,
    toAddr,
    big.NewInt(1_000_000),
    big.NewInt(0),
    big.NewInt(time.Now().Add(time.Hour).Unix()),
    nonce,
    big.NewInt(8453),
)
if err != nil {
    log.Fatal(err)
}
```

---

### `BuildPaymentHeader`

```go
func BuildPaymentHeader(
    privateKey *ecdsa.PrivateKey,
    req *PaymentRequirement,
    from common.Address,
    chainID *big.Int,
) (string, error)
```

Constructs the `X-PAYMENT` header value from a payment requirement. Generates a deterministic nonce from the sender, recipient, and amount, signs an EIP-3009 authorization, and returns a JSON payload.

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `privateKey` | `*ecdsa.PrivateKey` | Signer's private key |
| `req` | `*PaymentRequirement` | The payment requirement from the 402 response |
| `from` | `common.Address` | Payer's address |
| `chainID` | `*big.Int` | Chain ID for domain separator |

**Returns:**

| Type | Description |
|------|-------------|
| `string` | JSON-encoded payment header value |
| `error` | Non-nil if the requirement is nil, the amount is invalid, or signing fails |

**Header payload structure:**

```json
{
  "x402Version": 1,
  "scheme": "exact",
  "network": "base",
  "payload": {
    "signature": "hex...",
    "from": "0x...",
    "to": "0x...",
    "value": "1000000",
    "validAfter": "0",
    "validBefore": "...",
    "nonce": "hex..."
  }
}
```

**Example:**

```go
header, err := x402.BuildPaymentHeader(
    privateKey,
    &x402.PaymentRequirement{
        Scheme:            "exact",
        Network:           "base",
        MaxAmountRequired: "1000000",
        PayTo:             common.HexToAddress("0xPayee"),
        RequiredDeadline:  "1700000000",
    },
    fromAddr,
    big.NewInt(8453),
)
if err != nil {
    log.Fatal(err)
}
req.Header.Set("X-PAYMENT", header)
```

---

### `ParsePaymentRequirements`

```go
func ParsePaymentRequirements(data []byte) ([]PaymentRequirement, error)
```

Parses payment requirements from a 402 response body. Accepts both a JSON array and a single JSON object.

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `data` | `[]byte` | Raw JSON response body |

**Returns:**

| Type | Description |
|------|-------------|
| `[]PaymentRequirement` | Parsed payment requirements |
| `error` | Non-nil if JSON parsing fails for both array and single-object formats |

**Example:**

```go
body, _ := io.ReadAll(resp.Body)
requirements, err := x402.ParsePaymentRequirements(body)
if err != nil {
    log.Fatal(err)
}
for _, r := range requirements {
    fmt.Printf("Pay %s to %s via %s\n", r.MaxAmountRequired, r.PayTo.Hex(), r.Scheme)
}
```

---

## Client Constructor

### `NewX402Client`

```go
func NewX402Client(
    privateKey *ecdsa.PrivateKey,
    chainID *big.Int,
    budget *BudgetTracker,
    policy *X402Policy,
    config X402Config,
) *http.Client
```

Creates a standard `*http.Client` pre-configured with `X402Transport`. This is the simplest way to make x402-enabled HTTP requests.

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `privateKey` | `*ecdsa.PrivateKey` | Private key for signing payments |
| `chainID` | `*big.Int` | Chain ID |
| `budget` | `*BudgetTracker` | Budget tracker instance |
| `policy` | `*X402Policy` | Payment policy |
| `config` | `X402Config` | Transport configuration |

**Returns:** `*http.Client` -- a standard HTTP client with x402 payment handling.

**Example:**

```go
client := x402.NewX402Client(
    privateKey,
    big.NewInt(8453),
    bt,
    &x402.X402Policy{
        MaxPerRequest: big.NewInt(1_000_000),
        MaxPerPeriod:  big.NewInt(10_000_000),
    },
    x402.X402Config{
        AutoPay:        true,
        AllowedSchemes: []string{"exact"},
    },
)

resp, err := client.Get("https://api.example.com/paid-resource")
if err != nil {
    log.Fatal(err)
}
defer resp.Body.Close()
```

---

## Types

See also: [Types reference](types.md)

### `PaymentRequirement`

```go
type PaymentRequirement struct {
    Scheme            string                 `json:"scheme"`           // Payment scheme (e.g., "exact")
    Network           string                 `json:"network"`          // Network name (e.g., "base")
    MaxAmountRequired string                 `json:"maxAmountRequired"` // Amount in token's smallest unit
    Resource          string                 `json:"resource"`         // The resource being paid for
    Description       string                 `json:"description"`     // Human-readable description
    MimeType          string                 `json:"mimeType"`        // MIME type of the resource
    PayTo             common.Address         `json:"payTo"`           // Recipient address
    RequiredDeadline  string                 `json:"requiredDeadline"` // Unix timestamp deadline
    Extra             map[string]interface{} `json:"extra"`           // Additional scheme-specific data
}
```

### `X402Config`

```go
type X402Config struct {
    MaxAmount      *big.Int  // Maximum amount willing to pay per request
    AutoPay        bool      // Whether to automatically handle 402 responses
    AllowedSchemes []string  // Accepted payment schemes (empty = accept any)
    BudgetPeriod   uint64    // Budget period duration in seconds
}
```

### `PaymentRecord`

```go
type PaymentRecord struct {
    Resource  string          // URL of the resource paid for
    Amount    *big.Int        // Amount paid
    PayTo     common.Address  // Recipient address
    Timestamp uint64          // Unix timestamp of payment
    TxHash    common.Hash     // Transaction hash (if applicable)
    Network   string          // Network name
}
```

### `X402Policy`

```go
type X402Policy struct {
    MaxPerRequest  *big.Int                // Maximum amount per single payment
    MaxPerPeriod   *big.Int                // Maximum amount per budget period
    AllowedPayees  map[common.Address]bool // Permitted payee addresses
    AllowedDomains map[string]bool         // Permitted domain names
}
```

### `BudgetState`

```go
type BudgetState struct {
    TotalSpent     *big.Int        // Cumulative total spent (never resets)
    PeriodSpent    *big.Int        // Amount spent in the current period
    PeriodStart    uint64          // Unix timestamp when current period started
    PeriodDuration uint64          // Period length in seconds
    Records        []PaymentRecord // All payment records
}
```

### `X402Transport`

```go
type X402Transport struct {
    Base       http.RoundTripper   // Underlying transport
    PrivateKey *ecdsa.PrivateKey   // Signing key
    From       common.Address     // Payer's address (derived from PrivateKey)
    ChainID    *big.Int           // Chain ID
    Budget     *BudgetTracker     // Budget tracker
    Policy     *X402Policy        // Payment policy
    Config     X402Config         // Configuration
}
```

---

[<< Policy](policy.md) | [README](README.md) | [Next: Chain >>](chain.md)
